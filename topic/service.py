from sqlalchemy.ext.asyncio import AsyncSessionfrom core.exceptions import EntityBadRequestErrorfrom core.service import BaseServicefrom post.utils import generate_slugfrom topic.model import Topic, TopicOffer, TopicOfferStatusfrom topic.repository import TopicOfferRepository, TopicRepositoryfrom topic.schemas import AddTopicByOffer, CreateTopic, CreateTopicOffer, TopicFullShowfrom user.model import User, UserRoleEnumfrom post.service import PostServicefrom post.schemas import PostCreatefrom user.service import UserServicefrom helpers.search import Paginationfrom reaction.service import ReactionServiceclass TopicOfferService(BaseService[TopicOffer, TopicOfferRepository]):    def __init__(self, session: AsyncSession):        super().__init__(TopicOffer, session, TopicOfferRepository)    async def create_offer_topic(self, author: User, topic_create: CreateTopicOffer) -> TopicOffer:        return await self.create_item(            author_id=author.id, **topic_create.dict()        )class TopicService(BaseService[Topic, TopicRepository]):    def __init__(self, session: AsyncSession):        super().__init__(Topic, session, TopicRepository)        self.offer_service = TopicOfferService(session)        self.post_service = PostService(session)        self.user_service = UserService(session)        self.reaction_service = ReactionService(session)    async def get_full_topics(            self,            pagination: Pagination,    ) -> list[TopicFullShow]:        res = await self.repository.get_topics_with_content_counts(**pagination.dict())        return [            TopicFullShow(topic=topic, post_count=p_count, comment_count=c_count)            for topic, p_count, c_count in res        ]    async def get_full_topic(self, topic: Topic) -> TopicFullShow:        topic, p_count, c_count = \            await self.repository.get_topics_with_content_counts(topic_id=topic.id)        return TopicFullShow(topic=topic, post_count=p_count, comment_count=c_count)    async def create_topic(            self,            topic: CreateTopic,            approved_user: User,            suggested_user: User    ) -> Topic:        suggested_user = suggested_user if suggested_user else approved_user        topic.slug = generate_slug(topic.slug)        await self.check_already_exists(slug=topic.slug)        topic = await self.create_item(            **topic.dict(),            approved_user_id=approved_user.id,            suggested_user_id=suggested_user.id        )        post = PostCreate(            title=f"Добавлена тема {topic.slug}",            content=f"{topic.description}"        )        anonym = await self.user_service.get_item_by(            role=UserRoleEnum.ANONYMOUS        )        news = await self.get_item_by(            slug="news"        )        await self.post_service.create_post(anonym, post, topic_id=news.id)        return topic    async def create_topic_from_offer(            self,            topic: TopicOffer,            process: AddTopicByOffer,            process_user: User    ) -> Topic | TopicOffer:        if topic.status != TopicOfferStatus.PENDING:            raise EntityBadRequestError(                "offer-Тема", f"Предложенная тема уже имеет статус {topic.status}"            )        slug = generate_slug(process.slug)        await self.check_already_exists(slug=process.slug)        offer = await self.offer_service.update_item(            topic,            status=process.status,            process_user_id=process_user.id        )        if process.status == TopicOfferStatus.APPROVE:            topic = CreateTopic(                title=topic.title,                description=topic.description,                slug=slug            )            return await self.create_topic(                topic, process_user, process_user            )        return offer    async def create_news_topic(self, user: User) -> Topic:        news = await self.repository.get_one_by(slug="news")        if news:            return news        return await self.create_item(            title="Новости и обновления",            description="здесь публикуются новости и обновления форума",            slug="news",            approved_user_id=user.id,            suggested_user_id=user.id        )